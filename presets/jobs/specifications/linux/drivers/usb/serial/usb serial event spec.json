{
  "2.6.33": {
    "environment processes": {
      "usb_serial_scenario": {
        "actions": {
          "attach": {
            "callback": "%driver.attach%",
            "callback return value": "%ret%",
            "comment": "Do any local initialization of the device and private memory structure allocation.",
            "parameters": [
              "%resource%"
            ],
            "post-call": [
              "%ret% = ldv_filter_err_code(%ret%);"
            ]
          },
          "attached": {
            "comment": "Structure usb_serial is fully set up and local initialization has finished successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "close": {
            "callback": "%driver.close%",
            "comment": "Line discipline is being unplugged from the terminal.",
            "parameters": [
              "%resource%"
            ]
          },
          "deregister": {
            "condition": [
              "%driver% == $ARG1"
            ],
            "parameters": [
              "%driver%"
            ]
          },
          "disconnect1": {
            "callback": "%driver.disconnect%",
            "comment": "The device is unplugged.",
            "parameters": [
              "%resource%"
            ]
          },
          "disconnect2": {
            "callback": "%driver.disconnect%",
            "comment": "The device is unplugged.",
            "parameters": [
              "%resource%"
            ]
          },
          "free": {
            "comment": "Free usb_serial memory.",
            "statements": [
              "$FREE(%resource%);"
            ]
          },
          "init": {
            "comment": "Alloc memory and initialize an usb_serial structure that should be done by USB serial subsystem when the device is inserted.",
            "statements": [
              "$ALLOC(%resource%);"
            ]
          },
          "insert_device": {
            "comment": "Device is inserted in the system.",
            "process": "[probe].(<probed>.[attach].(<attached>.{main_workflow} | <not_attached>.[disconnect1]) | <not_probed>).{insert_device} | <free>.(deregister)"
          },
          "irq_write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%"
            ],
            "post-call": [
              "ldv_switch_to_process_context();"
            ],
            "pre-call": [
              "ldv_switch_to_interrupt_context();"
            ]
          },
          "main_workflow": {
            "comment": "All initializations of usb_serial and device has been done, call the other callbacks.",
            "process": "([suspend].(<suspended>.[resume] | <not_suspended>) | [port_probe].(<port_probed>.[open].(<opened>.{tty_layer} | <not_opened>.[port_remove]) | <not_port_probed>)).{main_workflow} | [disconnect2].[release].{insert_device}"
          },
          "not_attached": {
            "comment": "Local initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_opened": {
            "comment": "The tty line attachement has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_port_probed": {
            "comment": "USB serial port initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_probed": {
            "comment": "USB serial early initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_suspended": {
            "comment": "Suspending has been aborted.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "open": {
            "callback": "%driver.open%",
            "comment": "Line discipline is attached to the terminal.",
            "parameters": [
              "%resource%"
            ]
          },
          "opened": {
            "comment": "The tty line has been attached successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "port_probe": {
            "callback": "%driver.port_probe%",
            "callback return value": "%ret%",
            "comment": "Initialize serial port data.",
            "parameters": [
              "%resource%"
            ],
            "post-call": [
              "%ret% = ldv_filter_err_code(%ret%);"
            ]
          },
          "port_probed": {
            "comment": "USB serial port is initialized.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "port_remove": {
            "callback": "%driver.port_remove%",
            "comment": "Free serial port data.",
            "parameters": [
              "%resource%"
            ]
          },
          "probe": {
            "callback": "%driver.probe%",
            "callback return value": "%ret%",
            "comment": "Device has been inserted in the system.",
            "parameters": [
              "%resource%",
              "%usb_device_id%"
            ],
            "post-call": [
              "%ret% = ldv_post_probe(%ret%);"
            ],
            "pre-call": [
              "ldv_pre_probe();"
            ]
          },
          "probed": {
            "comment": "USB serial early initialization has finished successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "register": {
            "comment": "Begin USB serial callbacks invocation scenario.",
            "parameters": [
              "%driver%"
            ]
          },
          "release": {
            "callback": "%driver.release%",
            "comment": "Data structure usb_serial is about to be destroyed (This should be done after disconnect).",
            "parameters": [
              "%resource%"
            ]
          },
          "rest_line_attached_callbacks": {
            "callback": "%rest_line_attached_callbacks%",
            "parameters": [
              "%resource%"
            ]
          },
          "resume": {
            "callback": "%driver.resume%",
            "comment": "Warn the driver that the device is going to be resumed.",
            "parameters": [
              "%resource%"
            ]
          },
          "suspend": {
            "callback": "%driver.suspend%",
            "comment": "Warn the driver that the device is going to be suspended.",
            "parameters": [
              "%resource%"
            ]
          },
          "suspended": {
            "comment": "Device is going to be suspended.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "tty_layer": {
            "comment": "Call the rest callbacks from tty layer.",
            "process": " ([irq_write] | [write] | [rest_line_attached_callbacks]).{tty_layer} | [close].{main_workflow}"
          },
          "write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%"
            ]
          }
        },
        "comment": "Invoke USB serial callbacks",
        "headers": [
          "linux/tty.h",
          "linux/usb.h",
          "linux/usb/serial.h"
        ],
        "labels": {
          "driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ]
          },
          "resource": {
            "resource": true
          },
          "rest_line_attached_callbacks": {
            "callback": true
          },
          "ret": {
            "declaration": "int a",
            "value": "ldv_undef_int()"
          },
          "usb_device_id": {
            "interface": [
              "usb_serial.usb_device_id"
            ],
            "resource": true
          }
        },
        "process": "(!register).<init>.{insert_device}"
      },
       "tty_layer": {
        "actions": {
          "deregister_tty_layer": {
            "comment": "End up with USB serial tty layer callbacks invocation scenario.",
            "condition": [
              "%driver% == $ARG1"
            ],
            "parameters": [
              "%driver%"
            ]
          },
          "irq_write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%",
              "%port%"
            ],
            "post-call": [
              "ldv_switch_to_process_context();"
            ],
            "pre-call": [
              "ldv_switch_to_interrupt_context();"
            ]
          },
          "register_tty_layer": {
            "comment": "Begin USB serial tty layer callbacks invocation scenario.",
            "parameters": [
              "%driver%",
              "%port%",
              "%resource%"
            ]
          },
          "rest_line_attached_callbacks": {
            "callback": "%rest_line_attached_callbacks%",
            "parameters": [
              "%resource%"
            ]
          },
          "throttle": {
            "callback": "%driver.throttle%",
            "comment": "Notify the tty driver that input buffers for the line discipline are close to full.",
            "parameters": [
              "%resource%"
            ]
          },
          "tty_layer": {
            "comment": "Call the rest callbacks from tty layer.",
            "process": "([throttle].[unthrottle] | [irq_write] | [write] | [rest_line_attached_callbacks]).{tty_layer} | (deregister_tty_layer)"
          },
          "unthrottle": {
            "callback": "%driver.unthrottle%",
            "comment": "Notify the tty drivers that it should signals that characters can now be sent.",
            "parameters": [
              "%resource%"
            ]
          },
          "write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%",
              "%port%"
            ]
          }
        },
        "comment": "Invoke USB serial tty layer callbacks.",
        "headers": [
          "linux/tty.h",
          "linux/usb.h",
          "linux/usb/serial.h"
        ],
        "labels": {
          "driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ]
          },
          "port": {
            "interface": [
              "usb_serial.usb_serial_port"
            ],
            "resource": true
          },
          "resource": {
            "resource": true
          },
          "rest_line_attached_callbacks": {
            "callback": true
          }
        },
        "process": "(!register_tty_layer).{tty_layer}"
      }
    },
    "functions models": {
      "usb_serial_deregister": {
        "actions": {
          "assign": {
            "comment": "Get callbacks to deregister provided within 'usb_serial_driver' argument.",
            "statements": [
              "%usb_serial_driver% = $ARG1;"
            ]
          },
          "deregister": {
            "parameters": [
              "%usb_serial_driver%"
            ]
          }
        },
        "comment": "Deregister USB serial callbacks.",
        "labels": {
          "usb_serial_driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ],
            "parameter": true
          }
        },
        "process": "<assign>.[deregister]"
      },
      "usb_serial_register": {
        "actions": {
          "assign": {
            "comment": "Get callbacks to register provided within 'usb_serial_driver' argument.",
            "statements": [
              "%usb_serial_driver% = $ARG1;"
            ]
          },
          "fail": {
            "comment": "Fail USB callbacks registration.",
            "statements": [
              "ldv_failed_usb_register_driver();",
              "return ldv_undef_int_negative();"
            ]
          },
          "register": {
            "parameters": [
              "%usb_serial_driver%"
            ]
          },
          "success": {
            "comment": "Registration of usb_serial_driver callbacks has been finished successfully.",
            "statements": [
              "return 0;"
            ]
          }
        },
        "comment": "Register USB serial callbacks.",
        "labels": {
          "usb_serial_driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ],
            "parameter": true
          }
        },
        "process": "<assign>.[register].<success> | <fail>"
      }
    }
  },
  "3.14": {
    "environment processes": {
      "tty_layer": {
        "actions": {
          "deregister_tty_layer": {
            "comment": "End up with USB serial tty layer callbacks invocation scenario.",
            "condition": [
              "%driver% == $ARG1"
            ],
            "parameters": [
              "%driver%"
            ]
          },
          "irq_write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%",
              "%port%"
            ],
            "post-call": [
              "ldv_switch_to_process_context();"
            ],
            "pre-call": [
              "ldv_switch_to_interrupt_context();"
            ]
          },
          "register_tty_layer": {
            "comment": "Begin USB serial tty layer callbacks invocation scenario.",
            "parameters": [
              "%driver%",
              "%port%",
              "%resource%"
            ]
          },
          "rest_line_attached_callbacks": {
            "callback": "%rest_line_attached_callbacks%",
            "parameters": [
              "%resource%"
            ]
          },
          "throttle": {
            "callback": "%driver.throttle%",
            "comment": "Notify the tty driver that input buffers for the line discipline are close to full.",
            "parameters": [
              "%tty_struct%"
            ]
          },
          "tty_layer": {
            "comment": "Call the rest callbacks from tty layer.",
            "process": "([read_int_callback].([throttle].[unthrottle] | [irq_write] | [write] | [write_int_callback] | [read_bulk_callback] | [write_bulk_callback] | [process_read_urb]) | [rest_line_attached_callbacks]).<free>.(deregister_tty_layer)"
          },
          "unthrottle": {
            "callback": "%driver.unthrottle%",
            "comment": "Notify the tty drivers that it should signals that characters can now be sent.",
            "parameters": [
              "%tty_struct%"
            ]
          },
          "write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%",
              "%port%"
            ]
          },
          "read_int_callback": {
            "callback": "%driver.read_int_callback%",
            "comment": "Call read interrupt URB callback.",
            "parameters": [
              "%urb%"
            ],
            "pre-call": ["%urb% = %port%->interrupt_in_urb;"]
          },
          "write_int_callback": {
            "callback": "%driver.write_int_callback%",
            "comment": "Call write_int_callback callback.",
            "parameters": [
              "%urb%"
            ],
            "pre-call": ["%urb% = %port%->interrupt_out_urb;"]
          },
          "read_bulk_callback": {
            "callback": "%driver.read_bulk_callback%",
            "comment": "Call read_bulk_callback callback.",
            "parameters": [
              "%urb%"
            ],
            "pre-call": ["%urb% = %port%->read_urbs[0];"]
          },
          "write_bulk_callback": {
            "callback": "%driver.write_bulk_callback%",
            "comment": "Call write_bulk_callback callback.",
            "parameters": [
              "%urb%"
            ],
            "pre-call": ["%urb% = %port%->write_urbs[0];"]
          },
          "process_read_urb": {
            "callback": "%driver.process_read_urb%",
            "comment": "Call process_read_urb callback.",
            "parameters": [
              "%urb%"
            ],
            "pre-call": ["%urb% = %port%->read_urbs[0];"]
          },
          "init": {
            "comment": "Initialize a new URB.",
            "statements": [
              "%tty_struct% = ldv_xmalloc(sizeof(struct tty_struct));",
              "%tty_struct%->driver_data = %port%;"
            ]
          },
          "free": {
            "comment": "Free URB.",
            "statements": [
              "$FREE(%tty_struct%);"
            ]
          }
        },
        "comment": "Invoke USB serial tty layer callbacks.",
        "headers": [
          "linux/tty.h",
          "linux/usb.h",
          "linux/usb/serial.h"
        ],
        "labels": {
          "driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ]
          },
          "port": {
            "interface": [
              "usb_serial.usb_serial_port"
            ],
            "resource": true
          },
          "resource": {
            "resource": true
          },
          "urb": {
            "resource": true,
            "interface": [
              "usb_serial.urb"
            ]
          },
          "tty_struct": {
            "resource": true,
            "interface": [
              "usb_serial.tty_struct"
            ]
          },
          "rest_line_attached_callbacks": {
            "callback": true
          }
        },
        "process": "(!register_tty_layer).<init>.{tty_layer}",
        "reference": true
      },
      "usb_serial_scenario": {
        "actions": {
          "attach": {
            "callback": "%driver.attach%",
            "callback return value": "%ret%",
            "comment": "Do any local initialization of the device and private memory structure allocation.",
            "parameters": [
              "%resource%"
            ],
            "post-call": [
              "%ret% = ldv_filter_err_code(%ret%);"
            ]
          },
          "attached": {
            "comment": "Structure usb_serial is fully set up and local initialization has finished successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "close": {
            "callback": "%driver.close%",
            "comment": "Line discipline is being unplugged from the terminal.",
            "parameters": [
              "%port%"
            ]
          },
          "deregister": {
            "condition": [
              "%usb_device_id% == $ARG1"
            ],
            "parameters": [
              "%usb_device_id%"
            ]
          },
          "deregister_tty_layer": {
            "comment": "Deregister tty callbacks.",
            "parameters": [
              "%driver%"
            ]
          },
          "disconnect": {
            "callback": "%driver.disconnect%",
            "comment": "The device is unplugged.",
            "parameters": [
              "%resource%"
            ]
          },
          "free": {
            "comment": "Free usb_serial memory.",
            "statements": [
              "$FREE(%resource%);",
              "$FREE(%port%->write_urbs[0]);",
              "$FREE(%port%->interrupt_in_urb);",
              "$FREE(%port%->interrupt_out_urb);",
              "$FREE(%port%->read_urbs[0]);",
              "$FREE(%port%);"
            ]
          },
          "init": {
            "comment": "Alloc memory and initialize an usb_serial structure that should be done by USB serial subsystem when the device is inserted.",
            "statements": [
              "$ALLOC(%resource%);",
              "%port% = ldv_xmalloc(sizeof(struct usb_serial_port));",
              "%port%->write_urbs[0] = emg_make_urb(%port%);",
              "%port%->interrupt_in_urb = emg_make_urb(%port%);",
              "%port%->interrupt_out_urb = emg_make_urb(%port%);",
              "%port%->read_urbs[0] = emg_make_urb(%port%);"
            ]
          },
          "insert_device": {
            "comment": "Device is inserted in the system.",
            "process": "[probe].(<probed>.[attach].(<attached>.{main_workflow} | <not_attached>) | <not_probed>).{insert_device} | <free>.(deregister)"
          },
          "main_workflow": {
            "comment": "All initializations of usb_serial and device has been done, call the other callbacks.",
            "process": "([suspend].(<suspended>.([resume] | [reset_resume]) | <not_suspended>) | [port_probe].(<port_probed>.[open].(<opened>.[register_tty_layer].[deregister_tty_layer].[close] | <not_opened>).[port_remove]) | <not_port_probed>).{main_workflow} | [disconnect].[release].{insert_device}"
          },
          "not_attached": {
            "comment": "Local initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_opened": {
            "comment": "The tty line attachement has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_port_probed": {
            "comment": "USB serial port initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_probed": {
            "comment": "USB serial early initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_suspended": {
            "comment": "Suspending has been aborted.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "open": {
            "callback": "%driver.open%",
            "callback return value": "%ret%",
            "comment": "Line discipline is attached to the terminal.",
            "parameters": [
              "%resource%",
              "%port%"
            ]
          },
          "opened": {
            "comment": "The tty line has been attached successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "port_probe": {
            "callback": "%driver.port_probe%",
            "callback return value": "%ret%",
            "comment": "Initialize serial port data.",
            "parameters": [
              "%port%"
            ],
            "post-call": [
              "%ret% = ldv_filter_err_code(%ret%);"
            ]
          },
          "port_probed": {
            "comment": "USB serial port is initialized.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "port_remove": {
            "callback": "%driver.port_remove%",
            "comment": "Free serial port data.",
            "parameters": [
              "%port%"
            ]
          },
          "probe": {
            "callback": "%driver.probe%",
            "callback return value": "%ret%",
            "comment": "Device has been inserted in the system.",
            "parameters": [
              "%resource%",
              "%usb_device_id%"
            ],
            "post-call": [
              "%ret% = ldv_post_probe(%ret%);"
            ],
            "pre-call": [
              "ldv_pre_probe();"
            ]
          },
          "probed": {
            "comment": "USB serial early initialization has finished successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "register": {
            "comment": "Begin USB serial callbacks invocation scenario.",
            "parameters": [
              "%usb_device_id%"
            ]
          },
          "register_tty_layer": {
            "comment": "Now register tty callbacks.",
            "parameters": [
              "%driver%",
              "%port%",
              "%resource%"
            ]
          },
          "release": {
            "callback": "%driver.release%",
            "comment": "Data structure usb_serial is about to be destroyed (This should be done after disconnect).",
            "parameters": [
              "%resource%"
            ]
          },
          "reset_resume": {
            "callback": "%driver.reset_resume%",
            "comment": "The device has been resumed and it also has been reset.",
            "parameters": [
              "%resource%"
            ]
          },
          "resume": {
            "callback": "%driver.resume%",
            "comment": "Warn the driver that the device is going to be resumed.",
            "parameters": [
              "%resource%"
            ]
          },
          "suspend": {
            "callback": "%driver.suspend%",
            "comment": "Warn the driver that the device is going to be suspended.",
            "parameters": [
              "%resource%"
            ]
          },
          "suspended": {
            "comment": "Device is going to be suspended.",
            "condition": [
              "%ret% == 0"
            ]
          }
        },
        "comment": "Invoke USB serial callbacks.",
        "headers": [
          "linux/tty.h",
          "linux/usb.h",
          "linux/usb/serial.h"
        ],
        "labels": {
          "driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ]
          },
          "port": {
            "interface": [
              "usb_serial.usb_serial_port"
            ],
            "resource": true
          },
          "resource": {
            "resource": true
          },
          "ret": {
            "declaration": "int a",
            "value": "ldv_undef_int()"
          },
          "usb_device_id": {
            "interface": [
              "usb_serial.usb_device_id"
            ],
            "resource": true
          }
        },
        "process": "(!register).<init>.{insert_device}",
        "reference": true,
        "declarations": {
          "environment model": {
            "emg_make_urb": "struct urb *emg_make_urb(struct usb_serial_port *port);\n"
          }
        },
        "definitions": {
          "environment model": {
            "emg_make_urb": [
              "/* EMG_WRAPPER emg_make_urb */\n",
              "struct urb *emg_make_urb(struct usb_serial_port *port) {\n",
              "\t struct urb *new_urb;\n",
              "\t new_urb = ldv_xmalloc(sizeof(struct urb));\n",
              "\t new_urb->transfer_buffer = external_allocated_data();\n",
              "\t new_urb->context = port;\n",
              "\t ldv_assume(new_urb->actual_length > 0);\n",
              "\t ldv_assume(new_urb->actual_length < 1000);\n",
              "\t return new_urb;\n",
              "}\n",
              "\n"
            ]
          }
        }
      }
    },
    "functions models": {
      "usb_serial_deregister_drivers": {
        "actions": {
          "call": {
            "comment": "Call the function itself",
            "statements": [
              "usb_serial_deregister_drivers($ARG1);"
            ]
          },
          "deregister": {
            "comment": "Deregister USB serial callbacks.",
            "parameters": [
              "%usb_device_id%"
            ]
          }
        },
        "comment": "Deregister USB serial callbacks.",
        "headers": [
          "linux/tty.h",
          "linux/usb.h",
          "linux/usb/serial.h"
        ],
        "labels": {
          "usb_device_id": {
            "interface": [
              "usb_serial.usb_device_id"
            ],
            "resource": true
          }
        },
        "process": "[@deregister].<call>",
        "reference": true
      },
      "usb_serial_register_drivers": {
        "actions": {
          "assign": {
            "comment": "Get callbacks to register provided within 'usb_serial_driver' argument.",
            "statements": [
              "%usb_device_id% = $ARG3;"
            ]
          },
          "fail": {
            "comment": "Fail registration of USB serial callbacks.",
            "statements": [
              "return ldv_undef_int_negative();"
            ]
          },
          "register": {
            "comment": "Register USB serial callbacks.",
            "parameters": [
              "%usb_device_id%"
            ]
          },
          "success": {
            "comment": "Registration of USB serial callbacks has been successful.",
            "statements": [
              "ldv_assume(!usb_serial_register_drivers($ARG1, $ARG2, $ARG3));",
              "return 0;"
            ]
          }
        },
        "comment": "Register USB serial callbacks.",
        "headers": [
          "linux/tty.h",
          "linux/usb.h",
          "linux/usb/serial.h"
        ],
        "labels": {
          "usb_device_id": {
            "interface": [
              "usb_serial.usb_device_id"
            ],
            "parameter": true,
            "resource": true
          }
        },
        "process": "<assign>.[@register].<success> | <fail>",
        "reference": true
      }
    }
  },
  "3.2": {
    "environment processes": {
      "usb_serial_scenario": {
        "actions": {
          "attach": {
            "callback": "%driver.attach%",
            "callback return value": "%ret%",
            "comment": "Do any local initialization of the device and private memory structure allocation.",
            "parameters": [
              "%resource%"
            ],
            "post-call": [
              "%ret% = ldv_filter_err_code(%ret%);"
            ]
          },
          "attached": {
            "comment": "Structure usb_serial is fully set up and local initialization has finished successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "close": {
            "callback": "%driver.close%",
            "comment": "Line discipline is being unplugged from the terminal.",
            "parameters": [
              "%resource%"
            ]
          },
          "deregister": {
            "condition": [
              "%driver% == $ARG1"
            ],
            "parameters": [
              "%driver%"
            ]
          },
          "disconnect1": {
            "callback": "%driver.disconnect%",
            "comment": "The device is unplugged.",
            "parameters": [
              "%resource%"
            ]
          },"disconnect2": {
            "callback": "%driver.disconnect%",
            "comment": "The device is unplugged.",
            "parameters": [
              "%resource%"
            ]
          },
          "free": {
            "comment": "Free usb_serial memory.",
            "statements": [
              "$FREE(%resource%);"
            ]
          },
          "init": {
            "comment": "Alloc memory and initialize an usb_serial structure that should be done by USB serial subsystem when the device is inserted.",
            "statements": [
              "$ALLOC(%resource%);"
            ]
          },
          "insert_device": {
            "comment": "Device is inserted in the system.",
            "process": "[probe].(<probed>.[attach].(<attached>.{main_workflow} | <not_attached>.[disconnect1]) | <not_probed>).{insert_device} | <free>.(deregister)"
          },
          "irq_write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%"
            ],
            "post-call": [
              "ldv_switch_to_process_context();"
            ],
            "pre-call": [
              "ldv_switch_to_interrupt_context();"
            ]
          },
          "main_workflow": {
            "comment": "All initializations of usb_serial and device has been done, call the other callbacks.",
            "process": "([suspend].(<suspended>.[resume] | <not_suspended>) | [port_probe].(<port_probed>.[open].(<opened>.{tty_layer} | <not_opened>.[port_remove]) | <not_port_probed>)).{main_workflow} | [disconnect2].[release].{insert_device}"
          },
          "not_attached": {
            "comment": "Local initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_opened": {
            "comment": "The tty line attachement has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_port_probed": {
            "comment": "USB serial port initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_probed": {
            "comment": "USB serial early initialization has failed.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "not_suspended": {
            "comment": "Suspending has been aborted.",
            "condition": [
              "%ret% != 0"
            ]
          },
          "open": {
            "callback": "%driver.open%",
            "comment": "Line discipline is attached to the terminal.",
            "parameters": [
              "%resource%"
            ]
          },
          "opened": {
            "comment": "The tty line has been attached successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "port_probe": {
            "callback": "%driver.port_probe%",
            "callback return value": "%ret%",
            "comment": "Initialize serial port data.",
            "parameters": [
              "%resource%"
            ],
            "post-call": [
              "%ret% = ldv_filter_err_code(%ret%);"
            ]
          },
          "port_probed": {
            "comment": "USB serial port is initialized.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "port_remove": {
            "callback": "%driver.port_remove%",
            "comment": "Free serial port data.",
            "parameters": [
              "%resource%"
            ]
          },
          "probe": {
            "callback": "%driver.probe%",
            "callback return value": "%ret%",
            "comment": "Device has been inserted in the system.",
            "parameters": [
              "%resource%",
              "%usb_device_id%"
            ],
            "post-call": [
              "%ret% = ldv_post_probe(%ret%);"
            ],
            "pre-call": [
              "ldv_pre_probe();"
            ]
          },
          "probed": {
            "comment": "USB serial early initialization has finished successfully.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "register": {
            "comment": "Begin USB serial callbacks invocation scenario.",
            "parameters": [
              "%driver%"
            ]
          },
          "release": {
            "callback": "%driver.release%",
            "comment": "Data structure usb_serial is about to be destroyed (This should be done after disconnect).",
            "parameters": [
              "%resource%"
            ]
          },
          "rest_line_attached_callbacks": {
            "callback": "%rest_line_attached_callbacks%",
            "parameters": [
              "%resource%"
            ]
          },
          "resume": {
            "callback": "%driver.resume%",
            "comment": "Warn the driver that the device is going to be resumed.",
            "parameters": [
              "%resource%"
            ]
          },
          "suspend": {
            "callback": "%driver.suspend%",
            "comment": "Warn the driver that the device is going to be suspended.",
            "parameters": [
              "%resource%"
            ]
          },
          "suspended": {
            "comment": "Device is going to be suspended.",
            "condition": [
              "%ret% == 0"
            ]
          },
          "tty_layer": {
            "comment": "Call the rest callbacks from tty layer.",
            "process": " ([irq_write] | [write] | [rest_line_attached_callbacks]).{tty_layer} | [close].{main_workflow}"
          },
          "write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%"
            ]
          }
        },
        "comment": "Invoke USB serial callbacks.",
        "headers": [
          "linux/tty.h",
          "linux/usb.h",
          "linux/usb/serial.h"
        ],
        "labels": {
          "driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ]
          },
          "resource": {
            "resource": true
          },
          "rest_line_attached_callbacks": {
            "callback": true
          },
          "ret": {
            "declaration": "int a",
            "value": "ldv_undef_int()"
          },
          "usb_device_id": {
            "interface": [
              "usb_serial.usb_device_id"
            ],
            "resource": true
          }
        },
        "process": "(!register).<init>.{insert_device}"
      },
      "tty_layer": {
        "actions": {
          "deregister_tty_layer": {
            "comment": "End up with USB serial tty layer callbacks invocation scenario.",
            "condition": [
              "%driver% == $ARG1"
            ],
            "parameters": [
              "%driver%"
            ]
          },
          "irq_write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%",
              "%port%"
            ],
            "post-call": [
              "ldv_switch_to_process_context();"
            ],
            "pre-call": [
              "ldv_switch_to_interrupt_context();"
            ]
          },
          "register_tty_layer": {
            "comment": "Begin USB serial tty layer callbacks invocation scenario.",
            "parameters": [
              "%driver%",
              "%port%",
              "%resource%"
            ]
          },
          "rest_line_attached_callbacks": {
            "callback": "%rest_line_attached_callbacks%",
            "parameters": [
              "%resource%"
            ]
          },
          "throttle": {
            "callback": "%driver.throttle%",
            "comment": "Notify the tty driver that input buffers for the line discipline are close to full.",
            "parameters": [
              "%resource%"
            ]
          },
          "tty_layer": {
            "comment": "Call the rest callbacks from tty layer.",
            "process": "([throttle].[unthrottle] | [irq_write] | [write] | [rest_line_attached_callbacks]).{tty_layer} | (deregister_tty_layer)"
          },
          "unthrottle": {
            "callback": "%driver.unthrottle%",
            "comment": "Notify the tty drivers that it should signals that characters can now be sent.",
            "parameters": [
              "%resource%"
            ]
          },
          "write": {
            "callback": "%driver.write%",
            "comment": "Write a block of characters to the tty device in atomic context.",
            "parameters": [
              "%resource%",
              "%port%"
            ]
          }
        },
        "comment": "Invoke USB serial tty layer callbacks.",
        "headers": [
          "linux/tty.h",
          "linux/usb.h",
          "linux/usb/serial.h"
        ],
        "labels": {
          "driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ]
          },
          "port": {
            "interface": [
              "usb_serial.usb_serial_port"
            ],
            "resource": true
          },
          "resource": {
            "resource": true
          },
          "rest_line_attached_callbacks": {
            "callback": true
          }
        },
        "process": "(!register_tty_layer).{tty_layer}",
        "reference": true
      }
    },
    "functions models": {
      "usb_serial_deregister": {
        "actions": {
          "assign": {
            "comment": "Get callbacks to deregister provided within 'usb_serial_driver' argument.",
            "statements": [
              "%usb_serial_driver% = $ARG1;"
            ]
          },
          "deregister": {
            "parameters": [
              "%usb_serial_driver%"
            ]
          }
        },
        "comment": "Deregister USB serial callbacks.",
        "labels": {
          "usb_serial_driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ],
            "parameter": true
          }
        },
        "process": "<assign>.[deregister]"
      },
      "usb_serial_register": {
        "actions": {
          "assign": {
            "comment": "Get callbacks to register provided within 'usb_serial_driver' argument.",
            "statements": [
              "%usb_serial_driver% = $ARG1;"
            ]
          },
          "fail": {
            "comment": "Fail USB callbacks registration.",
            "statements": [
              "ldv_failed_usb_register_driver();",
              "return ldv_undef_int_negative();"
            ]
          },
          "register": {
            "parameters": [
              "%usb_serial_driver%"
            ]
          },
          "success": {
            "comment": "Registration of usb_serial_driver callbacks has been finished successfully.",
            "statements": [
              "return 0;"
            ]
          }
        },
        "comment": "Register USB serial callbacks.",
        "labels": {
          "usb_serial_driver": {
            "container": true,
            "interface": [
              "usb_serial.usb_serial_driver"
            ],
            "parameter": true
          }
        },
        "process": "<assign>.[register].<success> | <fail>"
      }
    }
  }
}